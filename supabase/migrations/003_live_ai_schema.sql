-- Enable Vector Extension for RAG
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================
-- LIVE AI SESSIONS
-- Persistent chat sessions (like "Rooms" or "Threads")
-- ============================================
CREATE TABLE IF NOT EXISTS ai_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE, -- Owner
  title TEXT NOT NULL DEFAULT 'New Session',
  description TEXT,
  session_type TEXT DEFAULT 'chat', -- 'chat', 'research', 'brainstorm'
  
  -- Configuration for this specific session
  settings JSONB DEFAULT '{}', -- Store active agents, temperature, etc.
  
  is_archived BOOLEAN DEFAULT false,
  is_public BOOLEAN DEFAULT false, -- If true, accessible by team
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- AI MESSAGES
-- Chat history for sessions
-- ============================================
CREATE TABLE IF NOT EXISTS ai_messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  session_id UUID REFERENCES ai_sessions(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE SET NULL, -- Null if generated by AI
  
  role TEXT NOT NULL, -- 'user', 'assistant', 'system'
  agent_id TEXT, -- ID of the specific agent persona (e.g. 'skeptic', 'scribe')
  
  content TEXT NOT NULL,
  
  -- For citations and sources
  citations JSONB DEFAULT '[]', -- Array of { source_id, text, url }
  metadata JSONB DEFAULT '{}', -- Token usage, processing time, etc.
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- KNOWLEDGE BASE (DOCUMENTS)
-- Global team knowledge base + Personal uploads
-- ============================================
CREATE TABLE IF NOT EXISTS knowledge_docs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL, -- Uploader
  
  title TEXT NOT NULL,
  original_name TEXT, -- Filename
  file_type TEXT, -- 'pdf', 'docx', 'url', 'text'
  url TEXT, -- Source URL or Storage Path
  
  summary TEXT, -- AI generated summary
  
  -- Content storage (for simple text/markdown)
  -- For large files, we might only store chunks in embeddings
  text_content TEXT, 
  
  is_processed BOOLEAN DEFAULT false,
  is_shared BOOLEAN DEFAULT true, -- Default to global team access
  
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- DOCUMENT EMBEDDINGS (VECTORS)
-- Chunks of documents for RAG
-- ============================================
CREATE TABLE IF NOT EXISTS doc_embeddings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  doc_id UUID REFERENCES knowledge_docs(id) ON DELETE CASCADE,
  
  content TEXT NOT NULL, -- The specific chunk of text
  embedding vector(768), -- Dimensions for Gemini Embeddings (text-embedding-004)
  
  chunk_index INTEGER,
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create index for fast vector similarity search
CREATE INDEX IF NOT EXISTS idx_doc_embeddings_embedding ON doc_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- ============================================
-- SESSION DOCUMENTS JUNCTION
-- Link specific docs to a session context
-- ============================================
CREATE TABLE IF NOT EXISTS session_docs (
  session_id UUID REFERENCES ai_sessions(id) ON DELETE CASCADE,
  doc_id UUID REFERENCES knowledge_docs(id) ON DELETE CASCADE,
  added_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (session_id, doc_id)
);

-- ============================================
-- TRIGGERS
-- ============================================
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'update_ai_sessions_updated_at'
  ) THEN
    CREATE TRIGGER update_ai_sessions_updated_at
      BEFORE UPDATE ON ai_sessions
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'update_knowledge_docs_updated_at'
  ) THEN
    CREATE TRIGGER update_knowledge_docs_updated_at
      BEFORE UPDATE ON knowledge_docs
      FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  END IF;
END $$;

-- ============================================
-- RLS POLICIES
-- ============================================

ALTER TABLE ai_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_docs ENABLE ROW LEVEL SECURITY;
ALTER TABLE doc_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_docs ENABLE ROW LEVEL SECURITY;

-- Sessions: Users see their own + public ones
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'ai_sessions'
      AND policyname = 'Users can view own or public sessions'
  ) THEN
    CREATE POLICY "Users can view own or public sessions" ON ai_sessions
      FOR SELECT USING (user_id = auth.uid() OR is_public = true);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'ai_sessions'
      AND policyname = 'Users can edit own sessions'
  ) THEN
    CREATE POLICY "Users can edit own sessions" ON ai_sessions
      FOR ALL USING (user_id = auth.uid());
  END IF;
END $$;

-- Messages: Users can view messages in sessions they have access to
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'ai_messages'
      AND policyname = 'Users can view messages in visible sessions'
  ) THEN
    CREATE POLICY "Users can view messages in visible sessions" ON ai_messages
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM ai_sessions 
          WHERE ai_sessions.id = ai_messages.session_id 
          AND (ai_sessions.user_id = auth.uid() OR ai_sessions.is_public = true)
        )
      );
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'ai_messages'
      AND policyname = 'Users can insert messages in visible sessions'
  ) THEN
    CREATE POLICY "Users can insert messages in visible sessions" ON ai_messages
      FOR INSERT WITH CHECK (
        EXISTS (
          SELECT 1 FROM ai_sessions 
          WHERE ai_sessions.id = session_id 
          AND (ai_sessions.user_id = auth.uid() OR ai_sessions.is_public = true)
        )
      );
  END IF;
END $$;

-- Knowledge Docs: Team-wide access (assuming simplified model where all auth users are 'team')
-- In a real multi-tenant app, we'd filter by organization_id
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'knowledge_docs'
      AND policyname = 'Users can view shared documents'
  ) THEN
    CREATE POLICY "Users can view shared documents" ON knowledge_docs
      FOR SELECT USING (is_shared = true OR user_id = auth.uid());
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'knowledge_docs'
      AND policyname = 'Users can upload documents'
  ) THEN
    CREATE POLICY "Users can upload documents" ON knowledge_docs
      FOR INSERT WITH CHECK (auth.uid() = user_id);
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'knowledge_docs'
      AND policyname = 'Users can edit own documents'
  ) THEN
    CREATE POLICY "Users can edit own documents" ON knowledge_docs
      FOR UPDATE USING (user_id = auth.uid());
  END IF;
END $$;

-- Embeddings inherit access from docs
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'doc_embeddings'
      AND policyname = 'Users can access embeddings of visible docs'
  ) THEN
    CREATE POLICY "Users can access embeddings of visible docs" ON doc_embeddings
      FOR SELECT USING (
        EXISTS (
          SELECT 1 FROM knowledge_docs 
          WHERE knowledge_docs.id = doc_embeddings.doc_id 
          AND (knowledge_docs.is_shared = true OR knowledge_docs.user_id = auth.uid())
        )
      );
  END IF;
END $$;

-- Session Docs Junction
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE tablename = 'session_docs'
      AND policyname = 'Users can manage docs in their sessions'
  ) THEN
    CREATE POLICY "Users can manage docs in their sessions" ON session_docs
      FOR ALL USING (
        EXISTS (
          SELECT 1 FROM ai_sessions 
          WHERE ai_sessions.id = session_id 
          AND ai_sessions.user_id = auth.uid()
        )
      );
  END IF;
END $$;

-- ============================================
-- VECTOR SEARCH FUNCTION (RPC)
-- ============================================
CREATE OR REPLACE FUNCTION match_documents (
  query_embedding vector(768),
  match_threshold float,
  match_count int,
  filter_user_id uuid DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  content text,
  similarity float,
  doc_title text,
  doc_url text
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    de.id,
    de.content,
    1 - (de.embedding <=> query_embedding) AS similarity,
    kd.title AS doc_title,
    kd.url AS doc_url
  FROM doc_embeddings de
  JOIN knowledge_docs kd ON de.doc_id = kd.id
  WHERE 1 - (de.embedding <=> query_embedding) > match_threshold
  AND (
    kd.is_shared = true 
    OR (filter_user_id IS NOT NULL AND kd.user_id = filter_user_id)
  )
  ORDER BY de.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

